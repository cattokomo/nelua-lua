##[[
	config.lua_bindings = config.lua_bindings or {
		target_version = LUA_TARGET_VERSION,
		include_dir = LUA_INCLUDE_DIR,
		ignore_cache = LUA_IGNORE_CACHE,
	}

	if not config.lua_bindings.target_version then
		static_error("set config.lua_bindings.target_version or define LUA_TARGET_VERSION with value either 51, 52, 53, 54, or jit to use LuaJIT")
	end

	local typev = type(config.lua_bindings.target_version)
	if not (
		typev == "number" and config.lua_bindings.target_version > 50 and config.lua_bindings.target_version < 55
		or
		typev == "string" and config.lua_bindings.target_version == "jit"
	) then
		static_error("invalid target version: " .. config.lua_bindings.target_version)
	end

	local luajit_header

	if config.lua_bindings.target_version == "jit" then
		config.lua_bindings.target_jit = true
		luajit_header = "<luajit.h>"
	end

	local lfs = require("lfs")
	local fs = require("nelua.utils.fs")
	local executor = require("nelua.utils.executor")
	local nldecl = require("nelua.plugins.nldecl")

	local include_dir = config.lua_bindings.include_dir or "."
	local cache_dir = fs.getusercachepath("nelua-lua-bindings")
	lfs.mkdir(cache_dir)

	local output = fs.join(cache_dir, "lua" .. config.lua_bindings.target_version .. ".nelua")
	local oldpath = config.path
	config.path = config.path .. ";" .. cache_dir .. "/?.nelua"

	if not config.lua_bindings.ignore_cache and not fs.isfile(output) then
		nldecl.generate_bindings_file({
		  output_file = output,
		  parse_includes = { "<lua.h>", "<lauxlib.h>", "<lualib.h>", luajit_header },
			include_dirs = { include_dir },
			include_names = { "^lua", "^LUA" },

			output_head = ([=[
				## cflags "-I%s"
				## cinclude "<lua.h>"
				## cinclude "<lauxlib.h>"
				## cinclude "<lualib.h>"
				%s
			]=]):format(include_dir, luajit_header and '## cinclude "<luajit.h>"' or "")
		})
	end
]]

require("lua"..#[tostring(config.lua_bindings.target_version)]#)
require("allocators.default")

local allocator = default_allocator

--! Namespace for Lua bindings
global lua = @record{}

--#[[ Types

global lua.State = @record{
	L: *lua_State,
}
## lua.value.metafields.State.is_lua_state = true

--]]#


--#[[ lua.State

function lua.State.new(): *lua.State
	local state = allocator:new(@lua.State)
	state.L = luaL_newstate()
	return state
end

--! Closes Lua state when not used
function lua.State:close(): void
	lua_close(self.L)
end

--[[ If enabled, Nelua will closes Lua state at GC time .
-- * Recommended if the system doesn't free Lua state on exit.
--]]
## if not pragmas.nogc and config.lua_bindings.enable_gc then
--! GC handler
function lua.State:__gc(): void
	self:close()
	allocator:delete(self)
end
## end

function lua.State:getL(): *lua_State
	return self.L
end

function lua.State:luajit_setmode(index: integer, feature: string <comptime>, mode: overload(boolean, string)): boolean
	## if config.lua_bindings.target_jit then
		local jit_feature: integer
		local jit_mode: integer

		## feature = feature.value:lower()
		## if feature == "engine" then
			jit_feature = LUAJIT_MODE_ENGINE
		## elseif feature == "func" then
			jit_feature = LUAJIT_MODE_FUNC
		## elseif feature == "allfunc" then
			jit_feature = LUAJIT_MODE_ALLFUNC
		## elseif feature == "allsubfunc" then
			jit_feature = LUAJIT_MODE_ALLSUBFUNC
		## elseif feature == "wrapcfunc" then
			jit_feature = LUAJIT_MODE_WRAPCFUNC
		## else
		## static_error("unknown luajit feature '" .. feature .. "'")
		## end

		## mode = mode.value
		## if mode == true then
			jit_mode = LUAJIT_MODE_ON
		## elseif mode == false then
			jit_mode = LUAJIT_MODE_OFF
		## elseif mode == "f" then
			jit_mode = LUAJIT_MODE_FLUSH
		## else
		## static_error("unknown mode '" .. mode .. "'")
		## end

		return luaJIT_setmode(self.L, index, jit_feature|jit_mode) == 1
	## else
		return true
	## end -- config.lua_bindings.target_jit
end

function lua.State:gettop(): integer
	return lua_gettop(self.L)
end

function lua.State:settop(index: integer): void
	lua_settop(self.L, index)
end

function lua.State:push(v: auto): void
	## if v.type.is_niltype then
		lua_pushnil(self.L)
	## elseif v.type.is_integral then
		lua_pushinteger(self.L, v)
	## elseif v.type.is_scalar then
		lua_pushnumber(self.L, v)
	## elseif v.type.is_stringy then
		lua_pushlstring(self.L, v, #v+1)
	## elseif v.type.is_boolean then
		lua_pushboolean(self.L, v and 1 or 0)
	## elseif v.type.is_pointer then
		lua_pushlightuserdata(self.L, v)
	## elseif v.type.nickname == "tupleT" then
		self:createtable(#[#v.type.fields]#, 0)

		## for _, vl in ipairs(v.type.fields) do
			self:push(v.#|vl.name|#)
			self:rawseti(-2, #[tonumber(vl.name:sub(2)) + 1]#)
		## end
	## elseif v.type.metafields then
		## if v.type.metafields.__pairs then
			self:createtable(0, 0)

			for k, v in pairs(v) do
				self:push(k)
				self:push(v)
				self:settable(-3)
			end
		## elseif v.type.metafields.__ipairs then
			self:createtable(0, 0)

			for i, v in ipairs(v) do
				self:push(v)
				self:rawseti(-2, i == 0 and i + 1 or i)
			end
		## end
	## elseif v.type.is_array then
		self:createtable(#v, 0)

		for i, v in ipairs(v) do
			self:push(v)
			self:rawseti(-2, i == 0 and i + 1 or i)
		end
	## elseif v.type.is_record or v.type.is_union then
		self:createtable(0, #[#v.type.fields]#)
	
		## for _, vl in ipairs(v.type.fields) do
			self:push(v.#|vl.name|#)
			self:setfield(-2, #[vl.name]#)
		## end
	## elseif v.type.is_type then
		## if v.value.is_record or v.value.is_union then
			self:createtable(0, #[#v.value.fields]#)

			## for _, vl in ipairs(v.value.fields) do
				self:push((@#[vl.type]#)())
				self:setfield(-2, #[vl.name]#)
			## end
		## elseif v.value.is_enum then
			self:createtable(0, #[#v.value.fields]#)

			## for _, vl in ipairs(v.value.fields) do
				self:push(#[vl.value]#)
				self:setfield(-2, #[vl.name]#)
			## end
		## end
	## else
	## static_error("unable to push a '" .. tostring(v.type) .. "'")
	## end
end

function lua.State:pushvalue(index: integer): integer
	lua_pushvalue(self.L, index)
	return self:gettop()
end

function lua.State:to(T: type, index: integer): auto
	## if T.value.is_stringy then
		return lua_tolstring(self.L, index, nilptr)
	## elseif T.value.is_integral then
		return lua_tointegerx(self.L, index, nilptr)
	## elseif T.value.is_scalar then
		return lua_tonumber(self.L, index)
	## elseif T.value.is_boolean then
		return lua_toboolean(self.L, index)
	## elseif T.value.is_pointer then
		return lua_topointer(self.L, index)
	## else
	## static_error("invalid type to convert to: " .. tostring(T.value))
	## end
end

function lua.State:createtable(nseq: integer, nrec: integer): void
	lua_createtable(self.L, nseq, nrec)
end

function lua.State:settable(index: integer): void
	lua_settable(self.L, index)
end

function lua.State:rawset(index: integer): void
	lua_rawset(self.L, index)
end

function lua.State:rawseti(index: integer, n: usize): void
	lua_rawseti(self.L, index, n)
end

function lua.State:setfield(index: integer, field: string): void
	lua_setfield(self.L, index, field)
end

--]]#

function lua.new_state(): *lua.State
	return lua.State.new()
end

##[[
	config.path = oldpath
]]
